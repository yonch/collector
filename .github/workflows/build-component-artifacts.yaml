name: build-component-artifacts

on:
  workflow_call:
    inputs:
      runner:
        description: "GitHub runner label to build on (e.g., ubuntu-latest, ubuntu-24.04-arm)"
        required: false
        default: ubuntu-latest
        type: string
      component:
        description: "Component to build (collector or nri-init)"
        required: true
        type: string
      push:
        description: "Push the built image to GHCR"
        required: false
        default: false
        type: boolean
      image-repository:
        description: "Target image repository (defaults to ghcr.io/<owner>/<repo>/<component>)"
        required: false
        type: string
      image-tag:
        description: "Image tag to use when pushing (defaults to pr-<run_id>)"
        required: false
        type: string
      upload-image-artifact:
        description: "Upload image tar as artifact"
        required: false
        default: true
        type: boolean
      upload-binary-artifact:
        description: "Upload extracted binary as artifact"
        required: false
        default: true
        type: boolean
    outputs:
      image_repo:
        description: "Image repository to use for tests (local/<component>)"
        value: ${{ jobs.build.outputs.image_repo }}
      image_tag:
        description: "Image tag to use for tests (build-<sha>-<run_id>)"
        value: ${{ jobs.build.outputs.image_tag }}
      image_artifact:
        description: "Name of the uploaded image artifact"
        value: ${{ jobs.build.outputs.image_artifact }}
      binary_artifact:
        description: "Name of the uploaded binary artifact"
        value: ${{ jobs.build.outputs.binary_artifact }}

jobs:
  build:
    name: Build ${{ inputs.component }} binary and image
    runs-on: ${{ inputs.runner }}
    timeout-minutes: 30
    outputs:
      image_repo: ${{ steps.out.outputs.image_repo }}
      image_tag: ${{ steps.out.outputs.image_tag }}
      image_artifact: ${{ steps.names.outputs.image_artifact }}
      binary_artifact: ${{ steps.names.outputs.binary_artifact }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute variables
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          comp="${{ inputs.component }}"
          case "$comp" in
            collector)
              image_name="collector"
              target="collector"
              bin_name="collector"
              needs_deps=1
              ;;
            nri-init)
              image_name="nri-init"
              target="nri-init"
              bin_name="nri-init"
              needs_deps=0
              ;;
            *)
              echo "Unsupported component: $comp" >&2
              exit 1
              ;;
          esac

          short_sha=$(git rev-parse --short=7 ${{ github.sha }})
          # Local-only tag to load and save
          local_image="local/${image_name}:build-${short_sha}-${{ github.run_id }}"
          echo "local_image=$local_image" >> "$GITHUB_OUTPUT"
          echo "target=$target" >> "$GITHUB_OUTPUT"
          echo "bin_name=$bin_name" >> "$GITHUB_OUTPUT"
          echo "needs_deps=$needs_deps" >> "$GITHUB_OUTPUT"

          # Publish target (if push=true)
          if [ -n "${{ inputs.image-repository }}" ]; then
            repo='${{ inputs.image-repository }}'
          else
            repo="ghcr.io/${{ github.repository }}/${image_name}"
          fi
          if [ -n "${{ inputs.image-tag }}" ]; then
            tag='${{ inputs.image-tag }}'
          else
            tag="pr-${{ github.run_id }}"
          fi
          echo "publish_image=${repo}:${tag}" >> "$GITHUB_OUTPUT"

      - name: Install build dependencies (collector only)
        if: steps.meta.outputs.needs_deps == '1'
        uses: awalsh128/cache-apt-pkgs-action@v1
        with:
          packages: clang libelf-dev make pkg-config unzip
          version: 1.0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: ${{ inputs.component }}
          cache-on-failure: true

      - name: Build release binary
        shell: bash
        run: |
          set -euo pipefail
          comp="${{ inputs.component }}"
          if [ "$comp" = "collector" ]; then
            cargo build --release --bin collector
          else
            cargo build --release -p nri-init
          fi
          mkdir -p dist
          cp -f "target/release/${{ steps.meta.outputs.bin_name }}" "dist/${{ steps.meta.outputs.bin_name }}"
          chmod +x "dist/${{ steps.meta.outputs.bin_name }}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: inputs.push == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build packaging image (load locally)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Containerfile
          target: ${{ steps.meta.outputs.target }}
          tags: ${{ steps.meta.outputs.local_image }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Optionally push to GHCR
        if: inputs.push == true
        shell: bash
        run: |
          set -euo pipefail
          docker image inspect "${{ steps.meta.outputs.local_image }}" >/dev/null 2>&1
          docker tag "${{ steps.meta.outputs.local_image }}" "${{ steps.meta.outputs.publish_image }}"
          docker push "${{ steps.meta.outputs.publish_image }}"

      - name: Compute artifact names
        id: names
        shell: bash
        run: |
          comp="${{ inputs.component }}"
          image_artifact="${comp}-image"
          binary_artifact="${comp}-binary"
          echo "image_artifact=$image_artifact" >> "$GITHUB_OUTPUT"
          echo "binary_artifact=$binary_artifact" >> "$GITHUB_OUTPUT"

      - name: Select output image metadata
        id: out
        shell: bash
        run: |
          # Always use local repo/tag for tests
          local_image="${{ steps.meta.outputs.local_image }}"
          image_repo="${local_image%%:*}"
          image_tag="${local_image##*:}"
          echo "image_repo=$image_repo" >> "$GITHUB_OUTPUT"
          echo "image_tag=$image_tag" >> "$GITHUB_OUTPUT"

      - name: Save image as tar
        if: inputs.upload-image-artifact == true
        shell: bash
        run: |
          docker image inspect "${{ steps.meta.outputs.local_image }}" >/dev/null 2>&1
          docker save "${{ steps.meta.outputs.local_image }}" -o image.tar

      - name: Upload image artifact
        if: inputs.upload-image-artifact == true
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.names.outputs.image_artifact }}
          path: image.tar
          retention-days: 7

      - name: Upload binary artifact
        if: inputs.upload-binary-artifact == true
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.names.outputs.binary_artifact }}
          path: dist/${{ steps.meta.outputs.bin_name }}
          retention-days: 7
